
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module pbf(

	//////////// LED //////////
	LEDG,
	LEDR,

	//////////// KEY //////////
	CPU_RESET_n,
	KEY,

	//////////// SW //////////
	SW,

	//////////// SEG7 //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// LED //////////
output		     [7:0]		LEDG;
output		     [9:0]		LEDR;

//////////// KEY //////////
input 		          		CPU_RESET_n;
input 		     [3:0]		KEY;

//////////// SW //////////
input 		     [9:0]		SW;

//////////// SEG7 //////////
output		     [6:0]		HEX0;
output		     [6:0]		HEX1;
output		     [6:0]		HEX2;
output		     [6:0]		HEX3;




//=======================================================
//  Structural coding
//=======================================================
wire clk = ~KEY[0];

parameter NCORES = 2;

// Shared wires
wire stall;

// Fetch <-> ALU
wire branch_en;
wire [15:0] branch_val;

// Fetch <-> ROM
wire [15:0] fetch_addr;
wire [15:0] fetch_data;

// Fetch <-> Select
wire [15:0] select_ins;

// Select <-> ALU
wire [15:0] ptr_select;
wire [15:0] alu_ins;
wire [15:0] alu_val;

// Select <-> RAM
wire ram_en;
wire [15:0] ram_ld_data;
wire [15:0] ram_ld_addr;

// ALU <-> WB
wire [15:0] wb_val;
wire wb_en;
wire [15:0] ptr_wb;

// Printing
wire [15:0] print;

// Registers
wire [NCORES*(1+1+1+16+16)-1:0] rf [2*NCORES]; 
reg  [NCORES*(1+1+1+16+16)-1:0] rf_reg;

// TODO: write back register to memory when done
// consider letting +++++ work

fetch(.clk(clk), .core_en(1'b1), .branch_en(branch_en), .branch_val(branch_val),
      .fetch_addr(fetch_addr), .fetch_data(fetch_data), .ins(select_ins));

select #(NCORES) 
        (.ins(select_ins), .ptr(ptr_select), .clk(clk), .stall(stall),
         .out_ins(alu_ins), .branch_en(branch_en), .val(alu_val),
         .mem_en_in(1'b0), .mem_en_out(ram_en), .mem_data_in(ram_ld_data),
         .mem_addr_out(ram_ld_addr), .rf_in(rf[0]), .rf_out(rf[1]));

// rf[1] wb rf[0] -> rf[0] select rf[1] -> rf [1] wb

alu(.clk(clk), .ins_in(alu_ins), .val_in(alu_val), .val_out(wb_val),
    .wb_en(wb_en), .ptr_select(ptr_select), .ptr_wb(ptr_wb),
    .branch_val(branch_val), .branch_en(branch_en), .print(print));

wb #(NCORES)
    (.clk(clk), .rf_in(rf_reg), .rf_out(rf[0]), 
     .val_in(wb_val), .wb_en_in(wb_en), .ptr_in(ptr_wb));

rom(.address(fetch_addr), 
    .inclock(clk),
    .inclocken(1'b1), 
    .outclock(clk),
    .outclocken(!stall),
    .q(fetch_data));

ram(.address(ram_ld_addr),
    .clock(clk),
	 .data(16'h0000),
	 .wren(1'b0),
	 .q(ram_ld_data));

// register file -- goes through wb, then select
always @(posedge clk) begin
    rf_reg <= rf[1];
end

/////// DEBUGGING ////////

reg [15:0] debug_disp;

always @(*) begin
    casex (SW[6:0])
        7'b0000xxx: debug_disp = rf[1][SW[2:0]*(1+1+1+16+16)    +: 16];
        7'b0100xxx: debug_disp = rf[1][SW[2:0]*(1+1+1+16+16)+16 +: 16];
        7'b0110xxx: debug_disp = {4'b0000,
                                 3'b000,
                                 rf[1][SW[2:0]*(1+1+1+16+16)+1+1+16+16 +: 1],
                                 3'b000,
                                 rf[1][SW[2:0]*(1+1+1+16+16)+1+16+16   +: 1],
                                 3'b000,
                                 rf[1][SW[2:0]*(1+1+1+16+16)+16+16     +: 1]};
        7'b1000xxx: debug_disp = {4'b0000,4'b0000,3'b000,stall,3'b000,branch_en};
        7'b1100xxx: debug_disp = SW[0]? ptr_select : ptr_wb; // ptr, else nptr
        7'b0111xxx: debug_disp = print;
        7'b0001xxx: debug_disp = fetch_data;
        7'b0010xxx: debug_disp = fetch_addr;
        default:   debug_disp = 16'h0000;
	endcase
end

seg16(debug_disp, {HEX3,HEX2,HEX1,HEX0});
assign LEDR[9:0] = fetch_data;

endmodule
