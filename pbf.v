
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module pbf(

	//////////// LED //////////
	LEDG,
	LEDR,

	//////////// KEY //////////
	CPU_RESET_n,
	KEY,

	//////////// SW //////////
	SW,

	//////////// SEG7 //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// LED //////////
output		     [7:0]		LEDG;
output		     [9:0]		LEDR;

//////////// KEY //////////
input 		          		CPU_RESET_n;
input 		     [3:0]		KEY;

//////////// SW //////////
input 		     [9:0]		SW;

//////////// SEG7 //////////
output		     [6:0]		HEX0;
output		     [6:0]		HEX1;
output		     [6:0]		HEX2;
output		     [6:0]		HEX3;




//=======================================================
//  Structural coding
//=======================================================
wire clk = ~KEY[0];

parameter NCORES = 2;

// Shared wires
wire stall;

// Fetch <-> ALU
wire branch_en;
wire [15:0] branch_val;

// Fetch <-> ROM
wire [15:0] fetch_addr;
wire [15:0] fetch_data;

// Fetch <-> Select
wire [15:0] select_ins;
wire core_en;

// Select <-> ALU
wire [15:0] ptr_select;
wire [15:0] alu_ins;
wire [15:0] alu_val;

// Select <-> RAM
wire ld_en;
wire [15:0] ram_ld_data;
wire [15:0] ram_ld_addr;
wire st_en;
wire [15:0] ram_st_data;
wire [15:0] ram_st_addr;

// ALU <-> WB
wire [15:0] wb_val;
wire wb_en;
wire [15:0] ptr_wb;

// Printing
wire [15:0] print;

// Registers
wire [NCORES*(1+1+1+16+16)-1:0] rf [2*NCORES]; 
reg  [NCORES*(1+1+1+16+16)-1:0] rf_reg;

// TODO: consider letting +++++ work

fetch(.clk(clk), .core_en(core_en), .stall(stall), 
      .branch_en(branch_en), .branch_val(branch_val),
      .fetch_addr(fetch_addr), .fetch_data(fetch_data), .ins(select_ins));

select #(NCORES) 
        (.ins(select_ins), .ptr(ptr_select), .clk(clk), .stall(stall),
         .out_ins(alu_ins), .branch_en(branch_en), .val(alu_val),
         .ld_en_in(1'b0), .ld_en_out(ld_en), 
         .ld_data_in(ram_ld_data), .ld_addr_out(ram_ld_addr), 
         .st_en_in(1'b0), .st_en_out(st_en),
         .st_data_out(ram_st_data), .st_addr_out(ram_st_addr),
         .core_en_in(1'b1), .core_en_out(core_en),
         .rf_in(rf[0]), .rf_out(rf[1]));

// rf[1] wb rf[0] -> rf[0] select rf[1] -> rf [1] wb

alu(.clk(clk), .ins_in(alu_ins), .val_in(alu_val), .val_out(wb_val),
    .wb_en(wb_en), .ptr_select(ptr_select), .ptr_wb(ptr_wb),
    .branch_val(branch_val), .branch_en(branch_en), .print(print));

wb #(NCORES)
    (.clk(clk), .rf_in(rf_reg), .rf_out(rf[0]), 
     .val_in(wb_val), .wb_en_in(wb_en), .ptr_in(ptr_wb));

rom(.address(fetch_addr), 
    .inclock(clk),
    .inclocken(1'b1), 
    .outclock(clk),
    .outclocken(!stall),
    .q(fetch_data));

ram(.address(ram_ld_addr),
    .clock(clk),
	.data(ram_st_data),
	.wren(st_en),
	.q(ram_ld_data));

// register file -- goes through wb, then select
always @(posedge clk) begin
    rf_reg <= rf[1];
end

initial begin
    rf_reg <= 0;
end

/////// DEBUGGING ////////

reg [15:0] debug_disp;

always @(*) begin
    casex (SW[6:0])
        7'b00000xx: debug_disp = rf[1][SW[1:0]*(1+1+1+16+16)    +: 16];
        7'b01000xx: debug_disp = rf[1][SW[1:0]*(1+1+1+16+16)+16 +: 16];
        7'b01100xx: debug_disp = {4'b0000,
                                 3'b000,
                                 rf[1][SW[1:0]*(1+1+1+16+16)+1+1+16+16 +: 1],
                                 3'b000,
                                 rf[1][SW[1:0]*(1+1+1+16+16)+1+16+16   +: 1],
                                 3'b000,
                                 rf[1][SW[1:0]*(1+1+1+16+16)+16+16     +: 1]};
        7'b00001xx: debug_disp = rf[rf_reg][SW[1:0]*(1+1+1+16+16)    +: 16];
        7'b01001xx: debug_disp = rf[rf_reg][SW[1:0]*(1+1+1+16+16)+16 +: 16];
        7'b01101xx: debug_disp = {4'b0000,
                                 3'b000,
                                 rf[rf_reg][SW[1:0]*(1+1+1+16+16)+1+1+16+16 +: 1],
                                 3'b000,
                                 rf[rf_reg][SW[1:0]*(1+1+1+16+16)+1+16+16   +: 1],
                                 3'b000,
                                 rf[rf_reg][SW[1:0]*(1+1+1+16+16)+16+16     +: 1]};
        7'b00011xx: debug_disp = rf[0][SW[1:0]*(1+1+1+16+16)    +: 16];
        7'b01011xx: debug_disp = rf[0][SW[1:0]*(1+1+1+16+16)+16 +: 16];
        7'b01111xx: debug_disp = {4'b0000,
                                 3'b000,
                                 rf[0][SW[1:0]*(1+1+1+16+16)+1+1+16+16 +: 1],
                                 3'b000,
                                 rf[0][SW[1:0]*(1+1+1+16+16)+1+16+16   +: 1],
                                 3'b000,
                                 rf[0][SW[1:0]*(1+1+1+16+16)+16+16     +: 1]};
        7'b10000xx: debug_disp = {4'b0000,4'b0000,3'b000,stall,3'b000,branch_en};
        7'b11000xx: debug_disp = SW[0]? ptr_select : ptr_wb; // ptr, else nptr
        7'b01110xx: debug_disp = print;
        7'b00010xx: debug_disp = SW[0] ? ram_ld_data : fetch_data;
        7'b00100xx: debug_disp = SW[0] ? ram_ld_addr : fetch_addr;
        7'b10001xx: debug_disp = SW[0] ? alu_val     : wb_val;
        7'b10011xx: debug_disp = SW[0] ? alu_ins     : select_ins;
        7'b11111xx: debug_disp = core_en;
        default:   debug_disp = 16'h0000;
	endcase
end

seg16({1'b1, debug_disp}, {HEX3,HEX2,HEX1,HEX0});
assign LEDR[9:0] = fetch_data[15:6];

endmodule
